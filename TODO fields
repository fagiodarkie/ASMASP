3) un oggetto istanziato con i campi uguali sarà visto con campi uguali, come i parametri di un metodo;
4) all'invocazione di un metodo, l'interprete crea una mappa ID -> oggetto nuovo e la offre al frame, che dovrebbe fare update dei suoi campi.

6) vengono inseriti gli AnValues variabili e le "espressioni" di AnValues, per poter gestire le modifiche ai campi (da definire).



Test da fare:
- metodi che assegnano nuovi thread a campi
	- possibilmente aggiungere supporto di contesto. Es: se init(a) = a.t1, creare un nuovo thread da contesto e 
	segnalare lo stato di questo thread - se t1 è running il nuovo thread dev'essere nella stessa condizione.
- metodi che modificano i campi con espressioni (a.fieldOne += 3)
- metodi che assegnano ai campi di un oggetto campi di un altro oggetto variabile. in particolare, detti a, b oggetti, i... interi, t... campi:
	- a.i1 = b.i2 + 3
	- a.t1 = b.t1
	- b.t1 = c.t1; a.t1 = b.t1 (result should be a.t1 = c.t1)
	- b.t1.join(); a.t1 = b.t1;
- metodi che assegnano oggetti ai campi.
	- a.c = b.c; c.t1.join();


[fatto] 2) gli AnValues hanno una mappa String->AnValue che ne gestisce i campi, che vengono anche riferiti come interi tramite ordinamento;
[fatto] 5) gli AnValues recuperano l'ID per gestire modifiche a cascata durante i metodi;
