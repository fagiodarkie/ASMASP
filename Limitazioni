Limitazioni attuali:
- profondità di analisi dei campi: 1 (oggetto con campi semplici);
- NO array;
- NO floating-point;
- NO return di diverse espressioni o assegnazione di diverse espressioni alla stessa cella di memoria;
- NO return di oggetti;
- NO campi con tipo inner classes (si generano loop infiniti di annidamento);
- tutti i campi devono essere inizializzati nel costruttore;


Casi non testati / estensioni:
- profondità di campi superiore a 1;


Test da fare:
- metodi che assegnano oggetti ai campi.
	- a.c = b.c; a.c.t1.join();


Test fatti:
- [fatto] metodi che assegnano nuovi thread a campi
	- [fatto] possibilmente aggiungere supporto di contesto. Es: se init(a) = a.t1, creare un nuovo thread da contesto e 
	segnalare lo stato di questo thread - se t1 è running il nuovo thread dev'essere nella stessa condizione.
- [fatto] metodi che modificano i campi con espressioni (a.fieldOne += 3)
- metodi che assegnano ai campi di un oggetto campi di un altro oggetto variabile. in particolare, detti a, b oggetti, i... interi, t... threads:
	- [fatto] a.i1 = b.i1
	- [fatto] a.i1 = b.i2 + 3
	- [fatto] a.t1 = b.t1
	- [fatto] b.t1 = c.t1; a.t1 = b.t1 (result should be a.t1 = c.t1)
	- [fatto] b.t1.join(); a.t1 = b.t1;
- [fatto] metodi che ritornano campi


[fatto] 2) gli AnValues hanno una mappa String->AnValue che ne gestisce i campi, che vengono anche riferiti come interi tramite ordinamento;
[fatto] 3) un oggetto istanziato con i campi uguali sarà visto con campi uguali, come i parametri di un metodo;
[fatto] 4) all'invocazione di un metodo, l'interprete crea una mappa ID -> oggetto nuovo e la offre al frame, che dovrebbe fare update dei suoi campi.
[fatto] 5) gli AnValues recuperano l'ID per gestire modifiche a cascata durante i metodi;
[NO] 6) vengono inseriti gli AnValues variabili e le "espressioni" di AnValues, per poter gestire le modifiche ai campi (da definire).